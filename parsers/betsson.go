package parsers

import (
	"fmt"
	"github.com/Jeffail/gabs"
	"github.com/gocolly/colly"
	"github.com/spf13/cast"
	"gorm.io/gorm"
	"haggle/models"
	"io/ioutil"
	"net/http"
)

type Betsson struct {
	Parser
	db     *gorm.DB
	config *models.SiteConfig
	c      *colly.Collector
	ID     int
}

/**
 first visit https://www.Netbet.gr/api/marketviews/findtimestamps?lang=el-GR&oddsR=1&timeZ=GTB%20Standard%20Time&usrGrp=G
then make request for each content key
*/
func (p *Betsson) Initialize() {

	p.c = GetCollector()

}

func (p *Betsson) SetConfig(c *models.SiteConfig) {
	p.config = c
	p.ID = c.SiteID
}

func (p *Betsson) GetConfig() *models.SiteConfig {
	return p.config
}

func (p *Betsson) Scrape() (bool, error) {

	return true, nil
}
func (p *Betsson) ScrapeHome() (bool, error) {
	//err := p.c.Visit(fmt.Sprintf("%s/%s", p.config.BaseUrl, p.config.Urls["home"]))
	//if err != nil {
	//	return false, err
	//}

	return true, nil
}

func (p *Betsson) ScrapeLive() (bool, error) {
	//err := p.c.Visit(fmt.Sprintf("%s/%s", p.config.BaseUrl, p.config.Urls["live"]))
	//if err != nil {
	//	return false, err
	//}
	return true, nil
}

func (p *Betsson) ScrapeToday() (bool, error) {
	//&from= #2021-09-02T21:00:00.000Z&to=2021-09-03T21:00:00.000Z
	//now := time.Now().Format(time.RFC3339)
	//tomorrow := time.Now().Add(time.Hour * 24).Format(time.RFC3339)
	//url := fmt.Sprintf("%s/%s&from=%s&to=%s", p.config.BaseUrl, p.config.Urls["day"], now, tomorrow)
	//err := p.c.Visit(url)
	//if err != nil {
	//	return false, err
	//}
	return true, nil
}

func (p *Betsson) ScrapeTournament(tournamentUrl string) (bool, error) {
	// first get tournaments
	tourUrl := fmt.Sprintf("%s/%s", p.config.BaseUrl, tournamentUrl)
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// curl --location --request GET 'https://www.betsson.gr/api/sb/v1/widgets/events-table/v2?maxMarketCount=5&categoryIds=1&regionIds=15&competitionIds=1698' \
	// --header 'authority: www.betsson.gr' \
	// --header 'content-type: application/json' \
	// --header 'accept: application/json, text/plain, */*' \
	// --header 'brandid: 4bf6590d-0a29-47f5-a705-42b7a04b7878' \
	// --header 'marketcode: en' \
	// --header 'x-sb-segment-guid: 70444b24-e56f-4b8a-9a93-c6d26817121c' \
	// --header 'sec-fetch-site: same-origin' \
	// --header 'sec-fetch-mode: cors' \
	// --header 'sec-fetch-dest: empty' \
	// --header 'referer: https://www.betsson.gr/el/stoixima/podosfairo?tab=competitionsAndLeagues' \
	// --header 'accept-language: en-US,en;q=0.9,el;q=0.8,it;q=0.7,fr;q=0.6,es;q=0.5'

	req, err := http.NewRequest("GET", tourUrl, nil)
	if err != nil {
		// handle err
	}
	req.Header.Set("Authority", "www.betsson.gr")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("Brandid", "4bf6590d-0a29-47f5-a705-42b7a04b7878")
	req.Header.Set("Marketcode", "en")
	req.Header.Set("X-Sb-Segment-Guid", "70444b24-e56f-4b8a-9a93-c6d26817121c")
	req.Header.Set("Sec-Fetch-Site", "same-origin")
	req.Header.Set("Sec-Fetch-Mode", "cors")
	req.Header.Set("Sec-Fetch-Dest", "empty")
	req.Header.Set("Referer", "https://www.betsson.gr/el/stoixima/podosfairo?tab=competitionsAndLeagues")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9,el;q=0.8,it;q=0.7,fr;q=0.6,es;q=0.5")

	res, _ := http.DefaultClient.Do(req)
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return false, err
	}

	eventList, err := p.MatchEventMarkets(body)
	if eventList != nil {
		for _, evt := range eventList {
			ParseEvent(p, evt.(map[string]interface{}))
		}
	}
	return true, nil
}

func (p *Betsson) SetDB(db *gorm.DB) {
	p.db = db
}

func (p *Betsson) GetDB() *gorm.DB {
	return p.db
}

func (p *Betsson) GetEventID(event map[string]interface{}) string {
	return event["id"].(string)
}

func (p *Betsson) GetEventName(event map[string]interface{}) string {
	if name, exist := event["label"]; exist {
		return name.(string)
	}
	return ""
}
func (p *Betsson) GetEventCanonicalName(event map[string]interface{}) string {
	if name, exist := event["label"]; exist {
		return name.(string)
	}
	return ""
}

func (p *Betsson) GetEventMarkets(event map[string]interface{}) []interface{} {
	markets := event["markets"].([]interface{})
	result := make([]interface{}, 0)
	for _, market := range markets {
		result = append(result, market)
	}
	return result
}

func (p *Betsson) GetEventDate(event map[string]interface{}) string {
	return event["startDate"].(string)
}

func (p *Betsson) ParseMarketName(market map[string]interface{}) string {
	if name, exist := market["label"]; exist {
		return name.(string)
	}
	return ""
}

func (p *Betsson) ParseSelectionName(selectionData map[string]interface{}) string {
	if name, exist := selectionData["label"]; exist {
		return name.(string)
	}
	return ""
}

func (p *Betsson) ParseSelectionPrice(selectionData map[string]interface{}) float64 {
	return selectionData["odds"].(float64)
}

func (p *Betsson) GetEventIsAntepost(event map[string]interface{}) bool {
	return false
}
func (p *Betsson) GetEventIsLive(event map[string]interface{}) bool {
	return false
}

func (p *Betsson) ParseSelectionLine(selectionData map[string]interface{}, marketData map[string]interface{}) float64 {
	line := 0.0
	if line, exist := marketData["lineValueRaw"]; exist {
		return cast.ToFloat64(line)
	}
	return line
}

func (p *Betsson) ParseMarketLine(market map[string]interface{}) float64 {
	line := 0.0
	if line, exist := market["lineValueRaw"]; exist {
		return cast.ToFloat64(line)
	}
	return line
}

func (p *Betsson) ParseMarketType(market map[string]interface{}) string {
	marketType := cast.ToString(market["marketTemplateId"])
	switch marketType {
	case "MW3W":
		return "SOCCER_MATCH_RESULT"
	case "DC":
		return "SOCCER_DOUBLE_CHANCE"
	case "BTTS":
		return "SOCCER_BOTH_TEAMS_TO_SCORE"
	case "test":
		return "SOCCER_AWAY_UNDER_OVER"
	case "MTG2W25":
		return "SOCCER_UNDER_OVER"
	case "test1":
		return "SOCCER_HOME_UNDER_OVER"
	}
	return ""
}

func (p *Betsson) MatchMarketType(market map[string]interface{}, marketType string) (models.MarketType, error) {
	switch marketType {
	case "SOCCER_MATCH_RESULT":
		return models.NewMatchResult().MarketType, nil
	case "SOCCER_UNDER_OVER":
		return models.NewOverUnder().MarketType, nil
	case "SOCCER_BOTH_TEAMS_TO_SCORE":
		return models.NewBtts().MarketType, nil
	}
	return models.MarketType{}, fmt.Errorf("could not match market type")
}

func (p *Betsson) ParseMarketId(market map[string]interface{}) string {
	return market["id"].(string)
}
func (p *Betsson) GetMarketSelections(market map[string]interface{}) []interface{} {
	return market["selections"].([]interface{})
}

func (p *Betsson) FetchEvent(e *models.Event) error {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// curl --location --request GET 'https://www.betsson.gr/api/sb/v1/widgets/view/v1?configurationKey=sportsbook.event&eventId=f-qRoojzZCzki4NC0N3BDrCg&excludedWidgetKeys=sportsbook.events-table-mini' \
	// 	--header 'content-type: application/json' \
	// 	--header 'accept: application/json, text/plain, *\*' \
	// 	--header 'x-sb-identifier: SPORTSBOOK_EVENT_WIDGET_REQUEST' \
	// 	--header 'x-obg-experiments: ssrClientConfiguration' \
	// 	--header 'brandid: 4bf6590d-0a29-47f5-a705-42b7a04b7878' \
	// 	--header 'marketcode: en' \
	// 	--header 'x-sb-segment-guid: 70444b24-e56f-4b8a-9a93-c6d26817121c' \
	// 	--header 'sec-ch-ua: "Chromium";v="92", " Not A;Brand";v="99", "Google Chrome";v="92"' \
	// 	--header 'sec-fetch-site: same-origin' \
	// 	--header 'sec-fetch-mode: cors' \
	// 	--header 'sec-fetch-dest: empty' \
	// 	--header 'accept-language: en-US,en;q=0.9,el;q=0.8,it;q=0.7,fr;q=0.6,es;q=0.5'
	url := fmt.Sprintf("%s/widgets/view/v1?configurationKey=sportsbook.event&eventId=%s&excludedWidgetKeys=sportsbook.events-table-mini", p.config.BaseUrl, e.BetradarID)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json, text/plain, **")
	req.Header.Set("X-Sb-Identifier", "SPORTSBOOK_EVENT_WIDGET_REQUEST")
	req.Header.Set("X-Obg-Experiments", "ssrClientConfiguration")
	req.Header.Set("Brandid", "4bf6590d-0a29-47f5-a705-42b7a04b7878")
	req.Header.Set("Marketcode", "en")
	req.Header.Set("X-Sb-Segment-Guid", "70444b24-e56f-4b8a-9a93-c6d26817121c")
	req.Header.Set("Sec-Ch-Ua", "\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"")
	req.Header.Set("Sec-Fetch-Site", "same-origin")
	req.Header.Set("Sec-Fetch-Mode", "cors")
	req.Header.Set("Sec-Fetch-Dest", "empty")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9,el;q=0.8,it;q=0.7,fr;q=0.6,es;q=0.5")

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
		return err
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return err
	}
	jsonParsed, err := gabs.ParseJSON(body)
	if err != nil {
		fmt.Println(err.Error())
		return err
	}

	widgets, err := jsonParsed.Search("data", "widgets").Children()
	for _, widget := range widgets {
		widgetData := widget.Data()
		if widgetData.(map[string]interface{})["type"] == "MarketList" {
			events, err := widget.Search("data", "data", "events").Children()
			markets, err := widget.Search("data", "data", "markets").Children()
			selections, err := widget.Search("data", "data", "selections").Children()

			eventList, err := p.MatchMarkets(markets, selections, events, err)
			if eventList != nil {
				for _, evt := range eventList {
					if markets, found := evt.(map[string]interface{})["markets"]; found {
						for _, market := range markets.([]interface{}) {
							parsedMarket, parseError := ParseMarket(p, market.(map[string]interface{}), *e)
							if parseError == nil {
								e.Markets = append(e.Markets, parsedMarket)
							}
						}
						return nil
					}
				}
				return nil
			}
		}
	}

	return fmt.Errorf("could not fetch details")
}

func (p *Betsson) GetEventUrl(event map[string]interface{}) string {
	if url, found := event["url"]; found {
		return url.(string)
	}
	return ""
}

func (p *Betsson) MatchEventMarkets(body []byte) (map[string]interface{}, error) {
	jsonParsed, err := gabs.ParseJSON(body)
	if err != nil {
		fmt.Println(err.Error())
	}

	events, err := jsonParsed.Search("data", "events").Children()
	markets, err := jsonParsed.Search("data", "markets").Children()
	selections, err := jsonParsed.Search("data", "selections").Children()
	return p.MatchMarkets(markets, selections, events, err)
}

func (p *Betsson) MatchMarkets(markets []*gabs.Container, selections []*gabs.Container, events []*gabs.Container, err error) (map[string]interface{}, error) {
	eventKeys := make(map[string]interface{}, 0)
	marketKeys := make(map[string]interface{}, 0)
	selectionKeys := make(map[string]interface{}, 0)
	for _, market := range markets {
		marketMap := market.Data().(map[string]interface{})
		marketMap["selections"] = make([]interface{}, 0)
		marketKeys[marketMap["id"].(string)] = marketMap
	}
	for _, selection := range selections {
		selectionMap := selection.Data().(map[string]interface{})
		if _, found := marketKeys[selectionMap["marketId"].(string)]; found {
			marketKeys[selectionMap["marketId"].(string)].(map[string]interface{})["selections"] =
				append(marketKeys[selectionMap["marketId"].(string)].(map[string]interface{})["selections"].([]interface{}), selectionMap)
		}
		selectionKeys[selectionMap["id"].(string)] = selectionMap
	}
	for _, event := range events {
		eventMap := event.Data().(map[string]interface{})
		eventMap["markets"] = make([]interface{}, 0)
		eventKeys[eventMap["id"].(string)] = eventMap
	}
	for _, market := range marketKeys {
		eventKeys[market.(map[string]interface{})["eventId"].(string)].(map[string]interface{})["markets"] =
			append(eventKeys[market.(map[string]interface{})["eventId"].(string)].(map[string]interface{})["markets"].([]interface{}), market)
	}
	if err != nil {
		return eventKeys, err
	}
	return eventKeys, nil
}
